library(boot)

get_ci_methods <- function(data, B = 500, B_inner = 100) {
  model <- lm(y ~ x1, data = data)
  est <- coef(model)["x1"]
  se_wald <- summary(model)$coefficients["x1", "Std. Error"]
  wald_ci <- c(est - 1.96 * se_wald, est + 1.96 * se_wald)
  
  boot_fun <- function(d, i) {
    d_sub <- d[i, ]
    m <- lm(y ~ x1, data = d_sub)
    beta_hat <- coef(m)["x1"]
    
    # 内层 Bootstrap 计算 se(beta_hat*) [cite: 74]
    # 为提速，内层使用简单的循环或再嵌套一个 boot
    inner_res <- replicate(B_inner, {
      d_inner <- d_sub[sample(nrow(d_sub), replace = TRUE), ]
      coef(lm(y ~ x1, data = d_inner))["x1"]
    })
    
    return(c(beta_hat, var(inner_res))) # 返回估计值和估计的方差
  }
  
  boot_out <- boot(data, statistic = boot_fun, R = B)
  
  # Percentile CI
  perc_ci <- boot.ci(boot_out, type = "perc")$percent[4:5]
  
  # Bootstrap-t CI [cite: 71]
  # t* = (beta_star - beta_hat) / se_star
  # 这里 boot.ci 可以自动处理，只要 statistic 返回了方差
  t_ci <- boot.ci(boot_out, type = "stud")$student[4:5]
  
  return(list(wald = wald_ci, perc = perc_ci, boot_t = t_ci, est = est))
}